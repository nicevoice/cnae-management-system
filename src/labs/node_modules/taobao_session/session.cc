#include <string.h>
#include <openssl/des.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <iconv.h>
#include <stdlib.h>
#include <node.h>
#include <v8.h>

using namespace v8;
using namespace node;

#define DES_ENCRYPT_BUF_SIZE(size) (((size)+7)/8*8)
int des_encrypt(const char *key, const char *msg, size_t size, char *enc)
{
	char tmp[8];
        int i, j;
        DES_cblock key2;
        DES_key_schedule schedule;

	if(!key || !msg || !enc) {
		return -1;
	}

        memcpy(key2, key,8);
        DES_set_odd_parity(&key2);
        DES_set_key_checked(&key2, &schedule);

	for(i=0; i<size; i+=8) {
		if(i+8<=size) {
			DES_ecb_encrypt((const_DES_cblock*)(msg+i), (DES_cblock*)(enc+i), &schedule, DES_ENCRYPT);
		}else {
			memset(tmp, 0, 8);
			memcpy(tmp, msg+i, size-i);
                	DES_ecb_encrypt((const_DES_cblock*)tmp, (DES_cblock*)(enc+i), &schedule, DES_ENCRYPT);
		}
	}
        return 0;
}

#define DES_DECRYPT_BUF_SIZE(size) (size)
int des_decrypt(const char *key, const char* enc, size_t size, char* msg)
{
        int i, j;
        DES_cblock key2;
        DES_key_schedule schedule;

        if(!key || !msg || !enc || size%8 != 0) { 
                return -1;
        }

        memcpy(key2, key,8);
        DES_set_odd_parity(&key2);
        DES_set_key_checked(&key2, &schedule);

        for(i=0; i<size; i+=8) {
                DES_ecb_encrypt((const_DES_cblock*)(enc+i), (DES_cblock*)(msg+i), &schedule, DES_DECRYPT);
        }

        return 0;
}

#define UTF8_GBK_STRLEN(len) (len)
int utf82gbk(char* input, char* output)
{
	iconv_t cd;
	size_t conv_size, inbytesleft, outbytesleft;

	if(!input || !output) {
		return -1;
	}

	inbytesleft = strlen(input)+1;
	outbytesleft = UTF8_GBK_STRLEN(strlen(input))+1;

	cd = iconv_open("GBK", "UTF-8");
	if(cd==(iconv_t)(-1)) {
		return -2;
	}

	conv_size = iconv(cd, &input, &inbytesleft, &output, &outbytesleft);
	iconv_close(cd);

	if(conv_size==(size_t)(-1) || inbytesleft!=0) {
		return -3;
	}

	return 0;
}

#define GBK_UTF8_STRLEN(len) (((len)+1)/2*3)
int gbk2utf8(const char* input, char* output)
{
        iconv_t cd;
        size_t conv_size, inbytesleft, outbytesleft;

        if(!input || !output) {
                return -1;
        }

        inbytesleft = strlen(input)+1;
        outbytesleft = GBK_UTF8_STRLEN(strlen(input))+1;

        cd = iconv_open("UTF-8", "GBK");
        if(cd==(iconv_t)(-1)) {
                return -2;
        }

        conv_size = iconv(cd, (char **)&input, &inbytesleft, &output, &outbytesleft);
        iconv_close(cd);

        if(conv_size==(size_t)(-1) || inbytesleft!=0) {
                return -3;
        }

        return 0;
}


#define BASE64_ENCODE_STRLEN(size) (((size)+2)/3*4)
int base64_encode(const char *msg, size_t size, char *enc)
{
	BIO *bio, *b64;
	char *data;
	long len;
	size_t line;
	int i;

	if(!msg || !enc) {
		return -1;
	}

	b64 = BIO_new(BIO_f_base64());
	bio = BIO_new(BIO_s_mem());
	b64 = BIO_push(b64, bio);
	BIO_write(b64, msg, size);
	BIO_flush(b64);

	len = BIO_get_mem_data(b64, &data);
	if(len<=0) {
		BIO_free_all(b64);
		return -2;
	}
	line = (len+64)/65;
	if(BASE64_ENCODE_STRLEN(size)!=len-line) {
		BIO_free_all(b64);
		return -3;
	}
	for(i=0; i<line-1; i++) {
		memcpy(enc+i*64, data+i*65, 64);
	}
	memcpy(enc+i*64, data+i*65, len-i*65-1);
	enc[BASE64_ENCODE_STRLEN(size)] = 0;

	BIO_free_all(b64);
	return 0;
}

#define BASE64_DECODE_BUF_SIZE(len) ((len)/4*3)
int base64_decode(const char *base64, char *msg)
{
	BIO *bio, *b64;
	int len, i, ret;
	size_t line;

	if(!base64 || !msg) {
		return -1;
	}
	if(strlen(base64)<=0 || strlen(base64)%4!=0) {
		return -2;
	}

	len = strlen(base64);
	line = (len+63)/64;
	char data[len+line+1];
	for(i=0; i<line-1; i++) {
		memcpy(data+i*65, base64+i*64, 64);
		data[(i+1)*65-1] = '\n';
	}
	memcpy(data+i*65, base64+i*64, len-i*64);
	data[len+line-1] = '\n';
	data[len+line] = 0;

	b64 = BIO_new(BIO_f_base64());
	bio = BIO_new_mem_buf(data, -1);
	b64 = BIO_push(b64, bio);

	ret = BIO_read(b64, msg, BASE64_DECODE_BUF_SIZE(strlen(data)));

	BIO_free_all(b64);
	return ret;	
}

#define URL_DECODE_STRLEN(len) (len)
const char *url_decode(const char *value, char *encode)
{
	int i, j, len=strlen(value);
	char a, b;

	if(!value || !encode) {
		return NULL;
	}

	if(strchr(value, '+')==NULL && strchr(value, '%')==NULL) {
		return value;
	}

	for(i=0, j=0; i<len; i++, j++) {
		if(value[i]=='+') {
			encode[j] = ' ';
			continue;
		}else if(value[i]=='%' && i<len-2) {
			a = value[i+1];
			b = value[i+2];
			if(a>='0' && a<='9') {
				a = (char)(a-'0');
			}else if(a>='a' && a<='f') {
				a = (char)(a-'a'+10);
			}else if(a>='A' && a<='F') {
				a = (char)(a-'A'+10);
			}else {
				encode[j] = value[i];
				continue;
			}
			if(b>='0' && b<='9') {
                                b = (char)(b-'0');
                        }else if(b>='a' && b<='f') {
                                b = (char)(b-'a'+10);
                        }else if(b>='A' && b<='F') {
                                b = (char)(b-'A'+10);
                        }else {
                                encode[j] = value[i];
                                continue;
                        }
			
			encode[j] = (char)((a<<4)|b);
			i+=2;
			continue;
		}
		encode[j] = value[i];
	}
	encode[j] = 0;

	return encode;
}

int parse_url(const char *url, char **map, size_t map_len)
{
	char *key, *utf8;
	const char *tmp;

        size_t k_len, v_len;
	int i, k_b=0, k_e=-1, v_b=-1, v_e=-1, len=strlen(url);
	int map_offset = 0;

	if(!url || !map) {
		return -1;
	}

        for(i=0; i<=len; i++) {
                if(url[i]=='=') {
                        if(k_e<k_b) {
                                k_e=i;
                                v_b=i+1;
                        }
                        continue;
                }
                if(url[i]=='&' || i==len) {
                        v_e=i;
                        if(k_e<k_b) {
                                k_e=i;
                                v_b=i;
                        }
                        k_len = k_e-k_b;
                        v_len = v_e-v_b;

			key = (char*)malloc(k_len+1);
                        strncpy(key, url+k_b, k_len);
                        key[k_len] = 0;

			char value[v_len+1];
                        strncpy(value, url+v_b, v_len);
                        value[v_len] = 0;

			char urldc[URL_DECODE_STRLEN(strlen(value))+1];
			if((tmp=url_decode(value, urldc))==NULL) {
				free(key);

				return -2;
			}
			utf8 = (char*)malloc(GBK_UTF8_STRLEN(strlen(tmp))+1);
			if(gbk2utf8(tmp, utf8)<0) {
				free(key);
				free(utf8);

				return -3;
			}

			if(map_offset<map_len) {
				map[map_offset*2] = key;
				map[map_offset*2+1] = utf8;
				map_offset++;
			}

			k_b=i+1;
                }
        }

	return 0;
}

void free_map(char **map, size_t map_len)
{
	int i, j;

	if(!map) {
		return;
	}
	for(i=0; i<map_len; i++) {
		for(j=0; j<2; j++) {
			if(map[i*2+j]!=NULL) {
				free(map[i*2+j]);
				map[i*2+j] = NULL;
			}
		}
	}
}

#define URL_PAIR_MAX 100
#define SKEY "!QAZ@#$%"
Handle<Value> decrypt(const Arguments& args)
{
	HandleScope scope;
	static int loop = 1;

	if(args.Length()==0 || !args[0]->IsString()) {
		return ThrowException(Exception::Error(String::New("Must give a string to decrypt")));
	}

	//base64 decode
	String::AsciiValue psession(args[0]);
	char enc[BASE64_DECODE_BUF_SIZE(strlen(*psession))];
	int enc_len;
	if((enc_len = base64_decode(*psession, enc))<0) {
		return ThrowException(Exception::Error(String::New("Base64 decode failed")));
	}

	//des decrypt
	char url[DES_DECRYPT_BUF_SIZE(enc_len)+1];
	url[sizeof(url)-1] = 0;
	if(des_decrypt(SKEY, enc, enc_len, url)<0) {
		return ThrowException(Exception::Error(String::New("Des decrypt failed")));
	}

	//split
	char *map[URL_PAIR_MAX*2] = {0};
	if(parse_url(url, map, URL_PAIR_MAX)<0) {
		free_map(map, URL_PAIR_MAX);
		return ThrowException(Exception::Error(String::New("Parse URL failed")));
	}

	Local<Object> object = Object::New();
	int i;
	for (i=0; i<URL_PAIR_MAX; i++) {
		if(map[i*2]!=NULL && map[i*2+1]!=NULL) {
			object->Set(String::NewSymbol(map[i*2]), String::New(map[i*2+1]));
		}
	}
	free_map(map, URL_PAIR_MAX);

	return scope.Close(object);
}

extern "C" void init (Handle<Object> target) {
	HandleScope scope;

	Local<FunctionTemplate> t = FunctionTemplate::New(decrypt);
	target->Set(String::NewSymbol("decrypt"), t->GetFunction());	
}
